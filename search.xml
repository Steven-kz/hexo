<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>反射</title>
      <link href="/2023/02/22/%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/02/22/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>概念:<font color="red" size="4"><code>在Java虚拟机中，加载类之后，会生成Class(字节码)文件,该对象包括了类的完整结构信息，通过这个Class对象可以看到类的所有结构，称之反射</code></font></p><p>作用:<font color="red" size="4"><code>Java反射是在动态的获取类， 类属性， 类方法， 类构造器等内部一些类的信息</code></font></p><h1 id="1-获取Class对象"><a href="#1-获取Class对象" class="headerlink" title="1.获取Class对象"></a>1.获取Class对象</h1><p> 那我们首先要获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将类编译成字节码文件 </span><br></pre></td></tr></table></figure><p> <strong>方式一:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一张创建方式                 类</span></span><br><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br></pre></td></tr></table></figure><p><strong>方式二:</strong></p><p>使用了forName()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第二种创建方式                             </span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(&quot;com.kz.c_reflect.Person&quot;);</span><br></pre></td></tr></table></figure><p><strong>方式三:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三种方式</span></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; aClass1 = <span class="keyword">new</span> <span class="title class_">Person</span>().getClass();</span><br></pre></td></tr></table></figure><h1 id="2-获取Constructor对象"><a href="#2-获取Constructor对象" class="headerlink" title="2.获取Constructor对象"></a>2.获取Constructor对象</h1><blockquote><p>获取Class对象之后我们可以获取字节码文件下的构造器</p></blockquote><p><strong>方式一:</strong></p><ul><li><ul><li><table><thead><tr><th>Constructor&lt;?&gt;[]</th></tr></thead><tbody><tr><td><code>getConstructors()</code>  返回包含一个数组 <code>Constructor</code>对象反射由此表示的类的所有公共构造  <code>类</code>对象。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过获取的字节码文件获取下面的构造方法  方法  属性等</span></span><br><span class="line"><span class="comment">//获取构造器</span></span><br><span class="line">Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line"><span class="comment">//获取所有的public构造器  需要遍历</span></span><br><span class="line">System.out.println(dogClass.getConstructors());</span><br></pre></td></tr></table></figure><p><strong>方式二:</strong></p><ul><li><ul><li><table><thead><tr><th><code>Constructor&lt;T&gt;</code></th></tr></thead><tbody><tr><td><code>getConstructor(类&lt;?&gt;... parameterTypes)</code>  返回一个 <code>Constructor</code>对象，该对象反映  <code>Constructor</code>对象表示的类的指定的公共 <code>类</code>函数。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        获取空参构造器</span></span><br><span class="line">System.out.println(dogClass.getConstructor());</span><br></pre></td></tr></table></figure><p><strong>方式三:</strong></p><ul><li><ul><li><table><thead><tr><th><code>Constructor&lt;?&gt;[]</code></th></tr></thead><tbody><tr><td><code>getDeclaredConstructors()</code>  返回一个反映 <code>Constructor</code>对象表示的类声明的所有  <code>Constructor</code>对象的数组 <code>类</code> 。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有的构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] dcsc = dogClass.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : dcsc) &#123;</span><br><span class="line">System.out.println(constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式四:</strong></p><ul><li><ul><li><table><thead><tr><th>&#96;Constructor<T></th></tr></thead><tbody><tr><td><code>getDeclaredConstructor(类&lt;?&gt;... parameterTypes)</code>  返回一个 <code>Constructor</code>对象，该对象反映  <code>Constructor</code>对象表示的类或接口的指定 <code>类</code>函数。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个除public之外的构造器</span></span><br><span class="line">System.out.println(dogClass.getDeclaredConstructor(<span class="type">int</span>.class));</span><br></pre></td></tr></table></figure><p>当我们获取了构造器之后我们就可以通过Class对象获取的构造器来实例化对象 <strong>方法:newInstance();</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Class对象</span></span><br><span class="line">Class&lt;Dog&gt; dogClass = Dog.class;</span><br><span class="line"><span class="comment">//获取构造器</span></span><br><span class="line">Constructor&lt;Dog&gt; declaredConstructor = dogClass.getDeclaredConstructor(<span class="type">int</span>.class);</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">System.out.println(declaredConstructor.newInstance(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><h1 id="3-获取Method对象"><a href="#3-获取Method对象" class="headerlink" title="3.获取Method对象"></a>3.获取Method对象</h1><blockquote><p>获取Class对象之后我们可以获取字节码文件下的方法</p></blockquote><p><strong>方式一:</strong></p><ul><li><ul><li><table><thead><tr><th><code>方法[]</code></th></tr></thead><tbody><tr><td><code>getMethods()</code>  返回包含一个数组 <code>方法</code>对象反射由此表示的类或接口的所有公共方法  <code>类</code>对象，包括那些由类或接口和那些从超类和超接口继承的声明。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Dog2&gt; dog2Class = Dog2.class;</span><br><span class="line"><span class="comment">//获取所有公开的方法包括父类的公开方法</span></span><br><span class="line"><span class="keyword">for</span> (Method method : dog2Class.getMethods()) &#123;</span><br><span class="line"> System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二:</strong></p><ul><li><ul><li><table><thead><tr><th>方法</th></tr></thead><tbody><tr><td><code>getMethod(String name,  类&lt;?&gt;... parameterTypes)</code>  返回一个 <code>方法</code>对象，它反映此表示的类或接口的指定公共成员方法 <code>类</code>对象。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个公开的方法</span></span><br><span class="line">System.out.println(dog2Class.getMethod(<span class="string">&quot;eat&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>方式三:</strong></p><ul><li><ul><li><table><thead><tr><th><code>方法[]</code></th></tr></thead><tbody><tr><td><code>getDeclaredMethods()</code>  返回包含一个数组 <code>方法</code>对象反射的类或接口的所有声明的方法，通过此表示  <code>类</code>对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有方法 不包括父类</span></span><br><span class="line"><span class="keyword">for</span> (Method declaredMethod : dog2Class.getDeclaredMethods()) &#123;</span><br><span class="line"> System.out.println(declaredMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式四：</strong></p><ul><li><ul><li><table><thead><tr><th>方法</th></tr></thead><tbody><tr><td><code>getDeclaredMethod(String name,  类&lt;?&gt;... parameterTypes)</code>  返回一个 <code>方法</code>对象，它反映此表示的类或接口的指定声明的方法 <code>类</code>对象</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取除public声明外的一个方法</span></span><br><span class="line">System.out.println(dog2Class.getDeclaredMethod(<span class="string">&quot;sleep&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>可以通过上面方式获取方法 我们获取方法之后，需要用方法.invokee(Object obj, Object… args)来调用</strong>，<font color="red" size="4"><code>第一个参数是Class对象，后面均为方法的形参</code></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先需要声明一个类对象</span></span><br><span class="line"><span class="type">Dog2</span> <span class="variable">dog2</span> <span class="operator">=</span> Dog2.class.getDeclaredConstructor().newInstance();</span><br><span class="line"><span class="type">Method</span> <span class="variable">sleep</span> <span class="operator">=</span> dog2Class.getDeclaredMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line"><span class="comment">//通过方法调用 第一个参数是类对象 第二个是参数</span></span><br><span class="line"><span class="comment">//私有方法 不能执行</span></span><br><span class="line"><span class="comment">//暴力反射</span></span><br><span class="line">sleep.setAccessible(<span class="literal">true</span>);</span><br><span class="line">sleep.invoke(dog2);</span><br></pre></td></tr></table></figure><p><strong>不管是私有的方法 构造器 属性 都不可用 除非使用暴力反射才可setAccessible(true)，才可使用private修饰</strong></p><h1 id="4-获取Field对象"><a href="#4-获取Field对象" class="headerlink" title="4:获取Field对象"></a>4:获取Field对象</h1><blockquote><p>获取Class对象之后我们可以获取字节码文件下的属性</p></blockquote><p><strong>方式一:</strong></p><ul><li><ul><li><table><thead><tr><th><code>Field[]</code></th></tr></thead><tbody><tr><td><code>getFields()</code>  返回包含一个数组 <code>Field</code>对象反射由此表示的类或接口的所有可访问的公共字段  <code>类</code>对象。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Dog3&gt; dog3Class = Dog3.class;</span><br><span class="line"><span class="comment">//获取所有公有属性</span></span><br><span class="line"><span class="keyword">for</span> (Field field : dog3Class.getFields()) &#123;</span><br><span class="line">System.out.println(field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二:</strong></p><ul><li><ul><li><table><thead><tr><th><code>Field</code></th></tr></thead><tbody><tr><td><code>getField(String name)</code>  返回一个 <code>Field</code>对象，它反映此表示的类或接口的指定公共成员字段  <code>类</code>对象。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个公有属性</span></span><br><span class="line">System.out.println(dog3Class.getField(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>方式三：</strong></p><ul><li><ul><li><table><thead><tr><th><code>Field[]</code></th></tr></thead><tbody><tr><td><code>getDeclaredFields()</code>  返回的数组 <code>Field</code>对象反映此表示的类或接口声明的所有字段 <code>类</code>对象。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有属性</span></span><br><span class="line"><span class="keyword">for</span> (Field declaredField : dog3Class.getDeclaredFields()) &#123;</span><br><span class="line">System.out.println(declaredField);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式四:</strong></p><ul><li><ul><li><table><thead><tr><th>&#96;Field</th></tr></thead><tbody><tr><td><code>getDeclaredField(String name)</code>  返回一个 <code>Field</code>对象，它反映此表示的类或接口的指定已声明字段 <code>类</code>对象。</td></tr></tbody></table></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个除public修饰外的属性</span></span><br><span class="line">System.out.println(dog3Class.getDeclaredField(<span class="string">&quot;age&quot;</span>));</span><br></pre></td></tr></table></figure><p>那我们如何给属性赋值？set()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//私有属性 需要暴力反射</span></span><br><span class="line">age.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//第一个值是对象 第二个是值</span></span><br><span class="line">age.set(dog3,<span class="number">18</span>);</span><br><span class="line">System.out.println(dog3);</span><br></pre></td></tr></table></figure><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p><strong>懒汉式:</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例的懒汉式实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.声明当前类对象，没有初始化。</span></span><br><span class="line">    <span class="comment">//此对象也必须声明为 static 的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.声明 public、static 的返回当前类对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>饿汉式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例的饿汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.内部创见类的对象</span></span><br><span class="line">    <span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"><span class="comment">//    public static final Bank instance=new Bank();   也可以这样写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供公共的静态的方法，返回类的对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;饿汉式：坏处:对象加载时间过长。</span><br><span class="line">&gt;好处:饿汉式是线程安全的。</span><br><span class="line"></span><br><span class="line">&gt;懒汉式：好处:延迟对象的创建。</span><br><span class="line">&gt;坏处:目前的写法，会线程不安全。</span><br></pre></td></tr></table></figure></blockquote><p>线程安全的懒汉式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance ==<span class="literal">null</span>)&#123;<span class="comment">//效率更高</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Bank.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            Bank instance=<span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>将类存储到本地文件(.ser)</p><p>在取出来 </p><p>类必须实现 <strong>Serializable</strong> 接口 才可以被序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//可被序列化 但获取不到值</span><br><span class="line">transient int size;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person.age=<span class="number">18</span>;</span><br><span class="line">person.size=<span class="number">20</span>;</span><br><span class="line">person.name=<span class="string">&quot;kz&quot;</span>;</span><br><span class="line">person.eat();</span><br><span class="line"><span class="comment">//输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:/aa/3.ser&quot;</span>);</span><br><span class="line"><span class="comment">//序列化流</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line"><span class="comment">//写出</span></span><br><span class="line">objectOutputStream.writeObject(person);</span><br><span class="line">objectOutputStream.close();</span><br><span class="line">fos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:/aa/3.ser&quot;</span>);</span><br><span class="line"><span class="comment">//序裂化流</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) objectInputStream.readObject();</span><br><span class="line">person1.eat();</span><br><span class="line">System.out.println(person1.name);</span><br><span class="line">System.out.println(person1.age);</span><br><span class="line">System.out.println(person.size);</span><br><span class="line">objectInputStream.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>主頁</title>
      <link href="/2023/02/22/index/"/>
      <url>/2023/02/22/index/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、Sleuth-Zipkin"><a href="#一、Sleuth-Zipkin" class="headerlink" title="一、Sleuth+Zipkin"></a>一、Sleuth+Zipkin</h2><p>Sleuth服务链路跟踪，可以记录⽇志，每⼀次的请求的全过程，并且会记录对应步骤的时间，还可以<br>示调⽤链路。<br>Zipkin是 Twitter 的⼀个开源项⽬，它基于 Google Dapper 实现，它致⼒于收集服务的定时数据，以解<br>决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。可视化⼯具，⼀般和Sleuth配合使<br>⽤，来实现微服务中服务的链路跟踪，记录请求中整个过程和所耗的时间。hex<br>市场上同类型的产品：SkyWalking等</p><h2 id="测试h"><a href="#测试h" class="headerlink" title="测试h"></a>测试h</h2><p>决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。可视化⼯具，⼀般和Sleuth配合使<br>⽤，来实现微服务中服务的链路跟踪，记录请求中整个过程和所耗的时间。hex<br>市场上同类型的产品：SkyWalking等</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swagger 接口文档</title>
      <link href="/2023/02/22/Swagger/Swagger/"/>
      <url>/2023/02/22/Swagger/Swagger/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>Swagger官网:<a href="https://swagger.io/">https://swagger.io/</a></p><p><font color=red ><code> Swagger是一款 RESTful 风格的 Web 服务框架</code> </font></p><p>那么问题来了 什么是RESTful？</p><p><font color=red><code> RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或 JSON格式定义。</code> </font></p><p><img src="/.%5Cimgs%5CSnipaste_2022-09-06_22-55-47.png" alt="Snipaste_2022-09-06_22-55-47"></p><h1 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dpendency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-编写Swagger配置类"><a href="#2-编写Swagger配置类" class="headerlink" title="2.编写Swagger配置类"></a>2.编写Swagger配置类</h1><p><img src="/.%5Cimgs%5C2.png" alt="2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//启⽤Swagger</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建⽂档的基本信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ApiInfo <span class="title function_">createApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>().</span><br><span class="line">                <span class="comment">// 设置页面标题</span></span><br><span class="line">                        title(<span class="string">&quot;xxx项⽬的接⼝⽂档&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置接口描述</span></span><br><span class="line">                .description(<span class="string">&quot;xxx项⽬是&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置联系方式</span></span><br><span class="line">                .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;https://blog.csdn.net/weixin_51779902?spm=1010.2135.3001.5343&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;0000@qq.com&quot;</span>))</span><br><span class="line">                <span class="comment">// 设置版本</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                <span class="comment">//构建</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就是ioc创建实例 修饰⽅法 ⽅法必须返回对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//等同于&lt;bean&gt; 配合@Configuration 会吧⽅法的返回值存储到IOC容器</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createDocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//SWAGGER_2:swagger版本  指定构建api文档的详细信息的方法：apiInfo()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2).apiInfo(createApi())</span><br><span class="line">                <span class="comment">//   RequestHandlerSelectors选择类注解方式 生成指定注解文档</span></span><br><span class="line">                .select().apis(RequestHandlerSelectors.</span><br><span class="line">                        withClassAnnotation(Api.class)).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-配置实体类"><a href="#3-配置实体类" class="headerlink" title="3.配置实体类"></a>3.配置实体类</h1><p><img src="/.%5Cimgs%5C5.png" alt="5"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;主键&quot; )</span> <span class="comment">//修饰实体类的属性 默认是false</span></span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;账户&quot;,required =true )</span> <span class="comment">//修饰实体类的属性</span></span><br><span class="line"><span class="meta">@ApiModelProperty(value = &quot;密码&quot;,required =true )</span> <span class="comment">//修饰实体类的属性</span></span><br></pre></td></tr></table></figure><h1 id="4-使用Swagger"><a href="#4-使用Swagger" class="headerlink" title="4.使用Swagger"></a>4.使用Swagger</h1><p><img src="/.%5Cimgs%5C4.png" alt="4"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/manger/&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;管理员的相关操作&quot;)</span> <span class="comment">//修饰类，为类加接口说明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MangerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MangerService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;新增&quot;,notes = &quot;实现账户的新增&quot;)</span><span class="comment">//修饰⽅法，为⽅法加说明</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;save.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(Manger manger)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> service.save(manger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询所有&quot;,notes = &quot;实现所有账户的数据&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;all.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">all</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-在application-yml配置"><a href="#4-在application-yml配置" class="headerlink" title="4.在application.yml配置"></a>4.在application.yml配置</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ANT_PATH_MATCHER</span>  <span class="comment">#防⽌swagger报错</span></span><br></pre></td></tr></table></figure><h1 id="5-运行测试"><a href="#5-运行测试" class="headerlink" title="5.运行测试"></a>5.运行测试</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/doc.htm</span><br></pre></td></tr></table></figure><h1 id="6-效果"><a href="#6-效果" class="headerlink" title="6.效果"></a>6.效果</h1><p><img src="/.%5Cimgs%5C6.png" alt="6"></p><p><strong>Swagger常⽤注解：</strong></p><p><strong>@Api(tags &#x3D; “说明信息”) 修饰类，控制层的类，为类加注释内容，通过tags属性</strong></p><p><strong>@ApiOperation(value &#x3D; “⽅法说明”,notes &#x3D; “⽅法详细介绍”) 修饰⽅法，映射⽅法，为⽅法加注释内容</strong></p><p><strong>@ApiParam(value&#x3D;”参数的说明”) 修饰⽅法的参数，为参数加说明</strong></p><p><strong>@ApiModelProperty(value &#x3D; “参数的说明”,required &#x3D; 是否必须传递) 修饰实体类的属性</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/02/22/git/Git/"/>
      <url>/2023/02/22/git/Git/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403233216157.png" alt="image-20220403233216157"></strong></p><p><code>everything-is-local</code> </p><blockquote><p>Author：glls</p><p>Version：9.0.2</p></blockquote><p>[TOC]</p><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><hr><blockquote><ul><li><p>在单人开发过程中，需要进行版本管理，以利于开发进度的控制。</p></li><li><p>在多人开发过程中，不仅需要版本管理，还需要进行多人协同控制。</p></li></ul></blockquote><p>结论：版本控制工具（软件）  能够实现文件版本控制 历史追踪  协同开发 等功能</p><h3 id="二、介绍"><a href="#二、介绍" class="headerlink" title="二、介绍"></a>二、介绍</h3><hr><blockquote><ul><li>Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li><li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li><li>官网：<a href="https://git-scm.com/">https://git-scm.com/</a></li></ul></blockquote><h3 id="三、Git安装"><a href="#三、Git安装" class="headerlink" title="三、Git安装"></a>三、Git安装</h3><hr><h4 id="3-1-下载Git"><a href="#3-1-下载Git" class="headerlink" title="3.1 下载Git"></a>3.1 下载Git</h4><blockquote><p>下载Git <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p></blockquote><h4 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h4><blockquote><p>安装，除了安装位置外，其他一直下一步即可</p></blockquote><h4 id="3-3-基本配置"><a href="#3-3-基本配置" class="headerlink" title="3.3 基本配置"></a>3.3 基本配置</h4><blockquote><ul><li><p>安装后，打开cmd ，自报家门</p></li><li><p>如下信息会在提交代码时要使用，记录在你的每次提交中。以后才知道哪次提交是谁做的。</p></li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;  #用户名</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;  #邮箱</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看信息</span></span><br><span class="line">git config -l </span><br></pre></td></tr></table></figure><h4 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h4><blockquote><p>测试：cmd中执行 ,查看git版本</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version  </span><br></pre></td></tr></table></figure><h3 id="四、架构"><a href="#四、架构" class="headerlink" title="四、架构"></a>四、架构</h3><hr><blockquote><ul><li><p>版本库：工作区中有一个隐藏目录 <code>.git</code>，这个目录不属于工作区，而是git的 <code>版本库</code>，是git管理的所有内容 </p></li><li><p>暂存区：版本库中包含一个临时区域，保存下一步要提交的文件。</p></li><li><p>分支：版本库中包含若干分支，提交的文件存储在分支中</p></li></ul></blockquote><table><thead><tr><th align="center">架构图</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403233630168.png" alt="image-20220403233630168"></td></tr></tbody></table><h3 id="五、仓库"><a href="#五、仓库" class="headerlink" title="五、仓库"></a>五、仓库</h3><hr><blockquote><p>对应的就是一个<a href="">目录</a>，这个目录中的所有文件被git管理起来。</p><p>以后会将一个<a href="">项目的根目录</a>，作为仓库。</p><p>仓库中的每个文件的改动 都由git跟踪。</p></blockquote><h4 id="5-1-新建仓库"><a href="#5-1-新建仓库" class="headerlink" title="5.1 新建仓库"></a>5.1 新建仓库</h4><blockquote><p>选择一个目录，执行指令：<a href="">git init</a></p></blockquote><table><thead><tr><th align="center">新建仓库</th><th align="center">仓库目录</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjiancangku.jpg" alt="新建仓库"></td><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjiancangku2.jpg" alt="新建仓库2"></td></tr></tbody></table><h4 id="5-2-工作区"><a href="#5-2-工作区" class="headerlink" title="5.2 工作区"></a>5.2 工作区</h4><blockquote><p>执行<a href="">git init</a>的目录即为工作区，如上例，<a href="">D:\repo1</a>目录即为工作区【不包含<a href="">.git</a>目录】</p></blockquote><blockquote><p>所有文件，都首先在工作区新建，然后可以存入仓库(版本库)，进行版本控制。</p></blockquote><h4 id="5-3-暂存区"><a href="#5-3-暂存区" class="headerlink" title="5.3 暂存区"></a>5.3 暂存区</h4><blockquote><p>暂存区也在 <a href="">.git</a> 目录内，工作区的文件进入仓库时，要先进入暂存区。</p></blockquote><h4 id="5-4-分支"><a href="#5-4-分支" class="headerlink" title="5.4 分支"></a>5.4 分支</h4><blockquote><p>版本控制，简单说，就是记录文件的诸多版本，分支就是这些版本的最终记录位置。</p></blockquote><h3 id="六、基本操作"><a href="#六、基本操作" class="headerlink" title="六、基本操作"></a>六、基本操作</h3><p>一般工作流程如下：</p><p>1．从远程仓库中<strong>克隆</strong> Git 资源作为本地仓库。</p><p>2．从本地仓库中checkout代码然后进行代码修改  –   隐式操作</p><p>3．在提交前先将代码提交到暂存区。</p><p>4．提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</p><p>5．在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</p><p>下图展示了 Git 的工作流程：</p><hr><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20200913100443112.png" alt="image-20200913100443112"></p><p>手把手操作步骤</p><p>1.创建一个文件夹  repo1 作为工作区</p><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403153648716.png" alt="image-20220403153648716"></p><p>2.在repo1  工作区 创建一个 仓库 ，此时这个目录内会有一个隐藏文件夹  .git  这个文件夹就是本地仓库</p><ul><li><p>创建本地仓库  可以通过 git init   命令 </p></li><li><p>也可用通过 小乌龟工具</p><p> <img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403153835082.png" alt="image-20220403153835082"></p></li></ul><p>3.在工作区的文件 需要 添加 和 提交 才能到本地仓库</p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403155429021.png" alt="image-20220403155429021" style="zoom: 80%;" /><p>通过添加    加到暂存区</p><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403155551166.png" alt="image-20220403155551166"></p><p>通过提交  把文件提交到本地仓库  提交的时候 写 注释&#x2F;日志</p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403155711886.png" alt="image-20220403155711886" style="zoom:80%;" /><p>修改本地文件  会和仓库文件不一致</p><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403155810004.png" alt="image-20220403155810004"></p><p>再次提交到本次仓库   本地仓库就会和工作区文件一致</p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403155857019.png" alt="image-20220403155857019" style="zoom:80%;" /><p>checkout </p><ul><li><p>切换&#x2F;检出 分支</p></li><li><p>用暂存区或者指定commit提交内容覆盖工作区内容    把暂存区 或者仓库的文件  拉回工作区</p><p>举个例子  现在咱们把工作区的文件删了   就是上图的  a.txt 文件，工作区没有了这个文件 ，但是 本地仓库是有的 怎么回复这个文件到工作区？  三种方式  </p><p>   方式1  通过版本库浏览器    还原到此版本</p><ul><li><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403160618527.png" alt="image-20220403160618527"></li></ul></li><li><p>​方式2     通过 小乌龟  切换检出  勾选 覆盖工作树  也可以把仓库文件 覆盖本地工作区文件</p><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403160719473.png" alt="image-20220403160719473"> </p></li><li><p>方式3    通过 check out 指令   把仓库或者暂存区文件 检出到 工作区</p><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403160847099.png" alt="image-20220403160847099"></p></li></ul><h4 id="6-1-查看仓库状态"><a href="#6-1-查看仓库状态" class="headerlink" title="6.1 查看仓库状态"></a>6.1 查看仓库状态</h4><blockquote><p>执行 <a href="">git  status</a> 可以看到工作区中文件的状态</p></blockquote><table><thead><tr><th align="center">未记录过的文件，是未跟踪状态</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chakanzhuangtai1.jpg" alt="查看状态1"></td></tr></tbody></table><h4 id="6-2-暂存文件"><a href="#6-2-暂存文件" class="headerlink" title="6.2 暂存文件"></a>6.2 暂存文件</h4><blockquote><p>执行 <a href="">git add .</a> 将工作区中的文件全部<a href="">存入暂存区</a></p></blockquote><table><thead><tr><th align="center">将工作区中的文件存入暂存区</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/zancunwenjian.jpg" alt="暂存文件"></td></tr></tbody></table><h4 id="6-3-提交文件"><a href="#6-3-提交文件" class="headerlink" title="6.3 提交文件"></a>6.3 提交文件</h4><blockquote><p>执行 <a href="">git commit -m “这里写提交的描述信息”</a> 作用是将暂存区的文件存入分支，形成一个版本</p></blockquote><table><thead><tr><th align="center">提交文件，形成一个版本</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/tijiaowenjian.jpg" alt="提交文件"></td></tr></tbody></table><h3 id="七、远程仓库"><a href="#七、远程仓库" class="headerlink" title="七、远程仓库"></a>七、远程仓库</h3><hr><blockquote><p>第5章中的仓库，其实是本地仓库。</p><p>当多人协同开发时，每人都在自己的本地仓库维护版本。</p><p>但很重要的一点是，多人之间需要共享代码、合并代码，此时就需要一个<a href="">远程仓库</a>。</p></blockquote><h4 id="7-1-远程仓库工作模式"><a href="#7-1-远程仓库工作模式" class="headerlink" title="7.1 远程仓库工作模式"></a>7.1 远程仓库工作模式</h4><table><thead><tr><th align="center">远程仓库工作模式</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/yuanchengcangku.jpg" alt="远程仓库"></td></tr></tbody></table><h4 id="7-2-远程仓库选型"><a href="#7-2-远程仓库选型" class="headerlink" title="7.2 远程仓库选型"></a>7.2 远程仓库选型</h4><blockquote><ul><li><p>有很多远程仓库可以选择，比如 github(<a href="https://github.com/">https://github.com/</a>),码云(<a href="https://gitee.com/">https://gitee.com/</a>)；</p><p> 此两种可以注册自己测试使用，但如果是商业项目，需要更多支持需要付费。</p></li><li><p>公司内部也可以有自己构建的远程仓库(<a href="http://glls.java.cn:8087/users/sign_in">http://glls.java.cn:8087/users/sign_in</a>)。</p></li></ul></blockquote><h4 id="7-3-基本操作"><a href="#7-3-基本操作" class="headerlink" title="7.3 基本操作"></a>7.3 基本操作</h4><blockquote><p>每个开发人员，在面对远程仓库时，会面临的一些基本操作。</p></blockquote><h5 id="7-3-1-注册git服务器账号"><a href="#7-3-1-注册git服务器账号" class="headerlink" title="7.3.1 注册git服务器账号"></a>7.3.1 注册git服务器账号</h5><blockquote><p>在 <a href="https://gitee.com/">码云</a> 注册账号，并登录。</p><p>进入公司后，很可能会使用公司自己搭建的git服务器，则账号向领导索要即可</p></blockquote><table><thead><tr><th align="center">点击注册，完成注册过程</th><th align="center"></th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/mayunzhuce.jpg" alt="码云注册"></td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">登录后显示主页</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/mayundenglu.jpg" alt="码云登录"></td></tr></tbody></table><h5 id="7-3-2-新建远程仓库"><a href="#7-3-2-新建远程仓库" class="headerlink" title="7.3.2 新建远程仓库"></a>7.3.2 新建远程仓库</h5><table><thead><tr><th align="center">创建远程私有仓库-01</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chuangjianyuanchengcangku1.jpg" alt="创建远程仓库1"></td></tr></tbody></table><table><thead><tr><th align="center">创建远程私有仓库-02</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chuangjianyuanchengcangku2.jpg" alt="创建远程仓库2"></td></tr></tbody></table><table><thead><tr><th align="center">创建远程私有仓库-03</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chuangjianyuanchengcangku3.jpg" alt="创建远程仓库3"></td></tr></tbody></table><h5 id="7-3-3-本地仓库关联远程仓库-分几种情况"><a href="#7-3-3-本地仓库关联远程仓库-分几种情况" class="headerlink" title="7.3.3 本地仓库关联远程仓库  分几种情况"></a>7.3.3 本地仓库关联远程仓库  分几种情况</h5><p><strong>情况1   本地有仓库   远程有仓库</strong></p><blockquote><p>本文档中选用仓库的 https协议的地址，将此地址关联到本地git中</p></blockquote><table><thead><tr><th align="center">如此后，本地即可用“origin” 代指远程仓库</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/guanlianyuanchengcangku.jpg" alt="关联远程仓库"></td></tr></tbody></table><h5 id="7-3-4-推送文件到远程仓库"><a href="#7-3-4-推送文件到远程仓库" class="headerlink" title="7.3.4 推送文件到远程仓库"></a>7.3.4 推送文件到远程仓库</h5><blockquote><p>将本地仓库中已经commit的内容push到远程仓库，以共享自己的代码。</p></blockquote><table><thead><tr><th align="center">push</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/pushdaoyuancheng.jpg" alt="push到远程"></td></tr></tbody></table><table><thead><tr><th align="center">输入凭证，如此码云才能接受此次上传的内容</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/pushdaoyuancheng_shurupingzheng.jpg" alt="push到远程_输入凭证"></td></tr></tbody></table><p><strong>情况2  本地没仓库  远程有仓库</strong>       克隆就好    克隆下来的仓库 和 远程仓库 直接关联的</p><h5 id="7-3-5-克隆远程仓库"><a href="#7-3-5-克隆远程仓库" class="headerlink" title="7.3.5 克隆远程仓库"></a>7.3.5 克隆远程仓库</h5><blockquote><p>如果仓库已经由别人创建完毕，我们需要其中的内容，则可以通过 <a href="">git clone</a> 将其复制到本地。</p></blockquote><table><thead><tr><th align="center">新建目录“repo2”，然后在其中执行 git clone</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/cloneyuanchengcangku.jpg" alt="clone远程仓库"></td></tr></tbody></table><table><thead><tr><th align="center">远程仓库，复制到本地，并自动初始化为一个本地仓库</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/cloneyuanchengcangku2.jpg" alt="clone远程仓库2"></td></tr></tbody></table><p><strong>情况3  本地有仓库  远程没有仓库</strong></p><p>小乌龟 不太好实现   ，后面 通过 idea来 ，idea 可以分享本地仓库到远程仓库</p><h5 id="7-3-6-代码共享"><a href="#7-3-6-代码共享" class="headerlink" title="7.3.6 代码共享"></a>7.3.6 代码共享</h5><blockquote><p>多人协同开发时，写好代码的<a href="">git push</a> 上传到远程仓库；需要代码的 <a href="">git pull</a> 拉取代码即可。 </p></blockquote><table><thead><tr><th align="center">有人再次将本地仓库内容，上传到了远程仓库</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/pullyuanchengcangku1.jpg" alt="pull远程仓库1"></td></tr></tbody></table><table><thead><tr><th align="center">重点：此时另一方如果想获得更新，则需要做一次拉取 git pull</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/pullyuanchengcangku2.jpg" alt="pull远程仓库2"></td></tr></tbody></table><h5 id="7-3-7-命令汇总"><a href="#7-3-7-命令汇总" class="headerlink" title="7.3.7 命令汇总"></a>7.3.7 命令汇总</h5><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>git   remote   add  标识名(master)  远程地址</td><td>本地关联远程仓库</td></tr><tr><td>git   push  标识名  master</td><td>将本地仓库内容上传到远程仓库</td></tr><tr><td>git   pull  标识名   master</td><td>从远程仓库下载内容到本地仓库</td></tr><tr><td>git   clone  远程地址</td><td>将远程仓库复制到本地，并自动形成一个本地仓库</td></tr></tbody></table><p>clone   把远程仓库克隆到本地  ， 克隆岛本地的仓库和远程仓库是直接关联的</p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403163426489.png" alt="image-20220403163426489" style="zoom:80%;" /><p>pull  拉取  拉取远程仓库的变化   拉取远程仓库的最新代码</p><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403163526304.png" alt="image-20220403163526304"></p><p>push   把本地仓库 的变化  推送到 远程仓库</p><p><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/image-20220403163557737.png" alt="image-20220403163557737"></p><h3 id="八、分支"><a href="#八、分支" class="headerlink" title="八、分支"></a>八、分支</h3><hr><h4 id="8-1-分支简介"><a href="#8-1-分支简介" class="headerlink" title="8.1 分支简介"></a>8.1 分支简介</h4><blockquote><ul><li><p>分支，是一个个版本最终存储的位置。</p></li><li><p>分支，就是一条时间线，每次<a href="">git commit</a>形成一个个版本，一个个版本依次存储在分支的一个个提交点上。</p></li></ul></blockquote><table><thead><tr><th align="center">分支由多个提交点组成，分支上会有一个指针，默认总是指向最新的提交点</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/fenzhituli1.jpg" alt="分支图例1"></td></tr></tbody></table><h4 id="8-2-分支操作"><a href="#8-2-分支操作" class="headerlink" title="8.2 分支操作"></a>8.2 分支操作</h4><h5 id="8-2-1-查看分支"><a href="#8-2-1-查看分支" class="headerlink" title="8.2.1 查看分支"></a>8.2.1 查看分支</h5><blockquote><ul><li><p>查看当前仓库的分支 <a href="">git branch</a></p></li><li><p>仓库中默认只有 master 分支</p></li><li><p>执行<a href="">git commit</a>时，默认是在master分支上保存版本。</p></li></ul></blockquote><table><thead><tr><th align="center">默认只有master分支</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chakanfenzhi-master.jpg" alt="查看分支-master"></td></tr></tbody></table><h5 id="8-2-2-创建分支"><a href="#8-2-2-创建分支" class="headerlink" title="8.2.2 创建分支"></a>8.2.2 创建分支</h5><blockquote><ul><li><p>在商业项目开发过程中，我们不会轻易的在<a href="">master</a>分支上做操作。</p></li><li><p>我们会新建一个<a href="">开发用的分支</a>，在此分支上做版本的记录。</p><p>当代码确实没有问题时，才会将开发分支上成熟的代码版本添加到<a href="">master</a>分支上。</p></li><li><p>保证开发过程中，可以及时记录版本，又保证<a href="">master</a>分支上每个提交点都是稳健版本。</p></li></ul></blockquote><table><thead><tr><th align="center">创建分支</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjianfenzhi.jpg" alt="新建分支"></td></tr></tbody></table><h5 id="8-2-3-切换分支"><a href="#8-2-3-切换分支" class="headerlink" title="8.2.3 切换分支"></a>8.2.3 切换分支</h5><blockquote><ul><li><p>默认情况下，当前使用的分支是 master分支</p></li><li><p>可以切换到 dev分支，则后续的<a href="">git commit</a> 便会在dev分支上新建版本(提交点)</p></li></ul></blockquote><table><thead><tr><th align="center">切换分支</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/qiehuanfenzhi.jpg" alt="切换分支"></td></tr></tbody></table><table><thead><tr><th align="center">再次查看分支情况</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chakanfenzhi.jpg" alt="查看分支"></td></tr></tbody></table><h4 id="8-3-新建分支细节"><a href="#8-3-新建分支细节" class="headerlink" title="8.3 新建分支细节"></a>8.3 新建分支细节</h4><blockquote><p>新建分支时，新分支，默认有哪些内容？分支中包含了哪些次提交？</p></blockquote><h5 id="8-3-1-新分支初始内容"><a href="#8-3-1-新分支初始内容" class="headerlink" title="8.3.1 新分支初始内容"></a>8.3.1 新分支初始内容</h5><blockquote><p>每个分支都有一个<a href="">指针</a>，新建一个分支，首先是新建一个<a href="">指针</a>。</p><p>而且新分支的指针会和当前分支指向<a href="">同一个提交点</a>。</p><p>新分支包含的提交点就是从第一个提交点到分支指针指向的提交点。</p></blockquote><table><thead><tr><th align="center">每个分支都有一个指针，新建一个分支，首先是新建一个指针</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjianfenzhixijie1.jpg" alt="新建分支细节1"></td></tr></tbody></table><h5 id="8-3-2-多分支走向"><a href="#8-3-2-多分支走向" class="headerlink" title="8.3.2 多分支走向"></a>8.3.2 多分支走向</h5><blockquote><p>在master分支和新分支，分别进行 <a href="">git add</a> 和 <a href="">git commit</a></p><p>分支情况如下图：</p></blockquote><table><thead><tr><th align="center">master分支未动，在dev分支增加一次commit</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjianfenzhixijie2.jpg" alt="新建分支细节2"></td></tr></tbody></table><table><thead><tr><th align="center">master分支增加一个commit，dev分支再增加一个commit</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjianfenzhixijie3.jpg" alt="新建分支细节3"></td></tr></tbody></table><h5 id="8-3-3-分支提交日志"><a href="#8-3-3-分支提交日志" class="headerlink" title="8.3.3 分支提交日志"></a>8.3.3 分支提交日志</h5><blockquote><p>查看分支的提交日志，进而看到分支中提交点的详细情况。</p></blockquote><table><thead><tr><th align="center">提交情况如下</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/tijiaorizhi.jpg" alt="提交日志"></td></tr></tbody></table><table><thead><tr><th align="center">查看当前分支的提交日志</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/tijiaorizhi2.jpg" alt="提交日志2"></td></tr></tbody></table><h4 id="8-4-分支合并"><a href="#8-4-分支合并" class="headerlink" title="8.4 分支合并"></a>8.4 分支合并</h4><blockquote><p>两个分支内容的合并</p></blockquote><blockquote><p><a href="">git merge 分支a</a>  合并分支a</p></blockquote><blockquote><p>合并的方式有两种：快速合并 和  三方合并。</p></blockquote><h5 id="8-4-1-快速合并"><a href="#8-4-1-快速合并" class="headerlink" title="8.4.1 快速合并"></a>8.4.1 快速合并</h5><blockquote><p>如果分支A当前的修改，是完全基于分支B的修改而来，则B分支合并A分支，就是移动指针即可。</p></blockquote><table><thead><tr><th align="center">合并前分支状态</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjianfenzhixijie2.jpg" alt="新建分支细节2"></td></tr></tbody></table><table><thead><tr><th align="center">快速合并效果（master 合并 dev）</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/kuaisufenzhihebing.jpg" alt="快速分支合并"></td></tr></tbody></table><h5 id="8-4-2-三方合并"><a href="#8-4-2-三方合并" class="headerlink" title="8.4.2 三方合并"></a>8.4.2 三方合并</h5><blockquote><p>在不具备快速合并的条件下，会采用三方合并。</p></blockquote><table><thead><tr><th align="center">合并前，分支状态</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/xinjianfenzhixijie3.jpg" alt="新建分支细节3"></td></tr></tbody></table><table><thead><tr><th align="center">三方合并，将<code>2</code>和<code>3</code>的更改都累加在<code>1</code>上，形成新的提交点</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/sanfanghebing.jpg" alt="三方合并"></td></tr></tbody></table><h5 id="8-4-3-合并冲突"><a href="#8-4-3-合并冲突" class="headerlink" title="8.4.3 合并冲突"></a>8.4.3 合并冲突</h5><blockquote><p>两个分支进行合并，但它们含有对同一个文件的修改，则在合并时出现冲突，git无法决断该保留改文件哪个分支的修改。</p></blockquote><h6 id="8-4-3-1-冲突演示"><a href="#8-4-3-1-冲突演示" class="headerlink" title="8.4.3.1 冲突演示"></a>8.4.3.1 冲突演示</h6><blockquote><p>场景模拟如下：</p></blockquote><table><thead><tr><th align="center">master分支修改hig.txt文件</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chongtu1.jpg" alt="冲突1"></td></tr></tbody></table><table><thead><tr><th align="center">dev分支修改hig.txt</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chongtu2.jpg" alt="冲突2"></td></tr></tbody></table><blockquote><p>在master分支 合并 dev分支</p></blockquote><table><thead><tr><th align="center">合并dev分支</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chongtu3.jpg" alt="冲突3"></td></tr></tbody></table><blockquote><p>此时，打开hig.txt 文件：</p></blockquote><table><thead><tr><th align="center">冲突后，git会将两个分支的内容都展示在文件中</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chongtu4.jpg" alt="冲突4"></td></tr></tbody></table><h6 id="8-4-3-2-冲突解决"><a href="#8-4-3-2-冲突解决" class="headerlink" title="8.4.3.2 冲突解决"></a>8.4.3.2 冲突解决</h6><blockquote><p>出现冲突后，如要由两个开发人员当面协商，该如何取舍，为冲突文件定义最终内容。</p><p>解决方案：</p><ol><li>保留某一方的，删除另一方的</li><li>保留双方的</li><li>但无论如何，要记得删除  <a href="">&lt;&lt;&lt;&lt;  &#x3D;&#x3D;&#x3D;&#x3D;  &gt;&gt;&gt;&gt;</a> 这些</li><li>本质是两人协商为冲突的内容，定制出合理的内容。</li></ol></blockquote><table><thead><tr><th align="center">根据协商，再次编辑文件</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chongtu5.jpg" alt="冲突5"></td></tr></tbody></table><table><thead><tr><th align="center">提交 再次编辑后的文件</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/chongtu6.jpg" alt="冲突6"></td></tr></tbody></table><h3 id="九、Idea关联Git"><a href="#九、Idea关联Git" class="headerlink" title="九、Idea关联Git"></a>九、Idea关联Git</h3><hr><h4 id="9-1-关联Git"><a href="#9-1-关联Git" class="headerlink" title="9.1 关联Git"></a>9.1 关联Git</h4><blockquote><p><a href="">File &gt; Settings</a>  关联过程是自动的</p></blockquote><table><thead><tr><th align="center">此处关联是Idea可以自动完成的</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-guanliangit.jpg" alt="idea-关联git"></td></tr></tbody></table><h4 id="9-2-创建仓库"><a href="#9-2-创建仓库" class="headerlink" title="9.2 创建仓库"></a>9.2 创建仓库</h4><blockquote><ul><li><p>新建项目后，将项目目录创建为git仓库</p></li><li><p>注意： 要在建仓库前，设置<a href="">忽略文件 “.gitignore”</a></p><p>作用：被忽略的文件会被版本记录忽略，版本中不包含它们。</p><p>范围：不需要和其他开发共享的文件，具体见下图。</p></li></ul></blockquote><table><thead><tr><th align="center">创建仓库前，先添加忽略文件</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-chuangjiancangku0.jpg" alt="idea-创建仓库0"></td></tr></tbody></table><table><thead><tr><th align="center">将项目目录初始化为一个仓库</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-chuangjiancangku1.jpg" alt="idea-创建仓库1"></td></tr><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-chuangjiancangku2.jpg" alt="idea-创建仓库2"></td></tr></tbody></table><h4 id="9-3-提交-commit"><a href="#9-3-提交-commit" class="headerlink" title="9.3 提交-commit"></a>9.3 提交-commit</h4><blockquote><p>创建好仓库后，做第一次提交。</p></blockquote><table><thead><tr><th align="center">选择提交菜单</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-commit.jpg" alt="idea-commit"></td></tr></tbody></table><table><thead><tr><th align="center">选择提交文件，定义提交信息</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-commit2.jpg" alt="idea-commit2"></td></tr></tbody></table><table><thead><tr><th align="center">之后会有些友好提示，可以忽略，点击<code>“commit”</code>即可</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-commit3.jpg" alt="idea-commit3"></td></tr></tbody></table><h4 id="9-4-创建分支"><a href="#9-4-创建分支" class="headerlink" title="9.4 创建分支"></a>9.4 创建分支</h4><blockquote><p>新建开发分支</p></blockquote><table><thead><tr><th align="center">点击右下角链接，即可</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-xinjianfenzhi.jpg" alt="idea-新建分支"></td></tr></tbody></table><table><thead><tr><th align="center">新建分支</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-xinjianfenzhi2.jpg" alt="idea-新建分支2"></td></tr></tbody></table><table><thead><tr><th align="center">查看当前分支</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-xinjianfenzhi3.jpg" alt="idea-新建分支3"></td></tr></tbody></table><h4 id="9-5-上传到远程仓库-push"><a href="#9-5-上传到远程仓库-push" class="headerlink" title="9.5 上传到远程仓库(push)"></a>9.5 上传到远程仓库(push)</h4><blockquote><ul><li><p>请首先参照第7章，创建一个远程仓库。</p></li><li><p>要求是裸库，且建议库名和项目名同名。</p></li></ul></blockquote><table><thead><tr><th align="center">选择<code>push</code>菜单</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-push.jpg" alt="idea-push"></td></tr></tbody></table><table><thead><tr><th align="center">定义远程仓库地址</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-push3.jpg" alt="idea-push3"></td></tr></tbody></table><table><thead><tr><th align="center">执行，push操作</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-push4.jpg" alt="idea-push4"></td></tr></tbody></table><table><thead><tr><th align="center">push成功后 ，弹窗提示</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-push5.jpg" alt="idea-push5"></td></tr></tbody></table><h4 id="9-6-复制到本地仓库-clone"><a href="#9-6-复制到本地仓库-clone" class="headerlink" title="9.6 复制到本地仓库(clone)"></a>9.6 复制到本地仓库(clone)</h4><blockquote><p>如果有建好的远程仓库，比如公司内已经在用的仓库，或者github，码云上的一些公开仓库，</p><p>可以将远程仓库的项目复制到本地使用。</p></blockquote><table><thead><tr><th align="center">点击克隆菜单</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-clone1.jpg" alt="idea-clone"></td></tr></tbody></table><table><thead><tr><th align="center">输入如远程仓库地址</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-clone2.jpg" alt="idea-clone2"></td></tr></tbody></table><table><thead><tr><th align="center">打开项目</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-clone3.jpg" alt="idea-clone3"></td></tr></tbody></table><table><thead><tr><th align="center">打开项目，选项</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-clone4.jpg" alt="idea-clone4"></td></tr></tbody></table><h4 id="9-7-更新本地项目"><a href="#9-7-更新本地项目" class="headerlink" title="9.7 更新本地项目"></a>9.7 更新本地项目</h4><blockquote><p>如果远程仓库有更新，则你的本地项目也需要一起更新。</p></blockquote><table><thead><tr><th align="center">选择pull菜单</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-pull1.jpg" alt="idea-pull1"></td></tr></tbody></table><table><thead><tr><th align="center">执行 pull操作</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-pull2.jpg" alt="idea-pull2"></td></tr></tbody></table><table><thead><tr><th align="center">更新日志显示</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-pull3.jpg" alt="idea-pull3"></td></tr></tbody></table><h4 id="9-8-冲突解决"><a href="#9-8-冲突解决" class="headerlink" title="9.8 冲突解决"></a>9.8 冲突解决</h4><blockquote><p>合并分支时，如果出现冲突，则需要解决冲突。</p></blockquote><table><thead><tr><th align="center">冲突出现，弹窗中可以选择如下</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-chongtu.jpg" alt="idea-冲突"></td></tr></tbody></table><table><thead><tr><th align="center">也可以直接修改冲突文件，然后commit即可</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/idea-chongtu2.jpg" alt="idea-冲突2"></td></tr></tbody></table><h3 id="十、多人协同开发"><a href="#十、多人协同开发" class="headerlink" title="十、多人协同开发"></a>十、多人协同开发</h3><hr><blockquote><p>多人开发协同，git操作</p></blockquote><h4 id="10-1-项目管理员-项目经理"><a href="#10-1-项目管理员-项目经理" class="headerlink" title="10.1 项目管理员( 项目经理 )"></a>10.1 项目管理员( 项目经理 )</h4><blockquote><p>1&gt; 由管理员负责创建一个远程库，初始的库中什么也没有，为裸库。库的名称建议和项目同名</p></blockquote><blockquote><p>2&gt; 管理员会在idea中创建一个初始项目,其中包含.gitignore文件。                                                                                           并在项目根目录下 建立本地库。并建立 dev分支。</p></blockquote><blockquote><p>3&gt; 管理员将本地库上传到远程库</p></blockquote><blockquote><p>4&gt; 将其他开发人员拉入远程库的 <a href="">开发成员列表中</a> ，使得其他开发人员可以访问该远程库。</p><p>流程如下：</p></blockquote><table><thead><tr><th align="center">点击添加成员</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/tianjiakaifachengyuan.jpg" alt="添加开发成员"></td></tr></tbody></table><table><thead><tr><th align="center">选择直接添加</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/tianjiakaifachengyuan2.jpg" alt="添加开发成员2"></td></tr></tbody></table><table><thead><tr><th align="center">提交</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/tianjiakaifachengyuan3.jpg" alt="添加开发成员3"></td></tr></tbody></table><table><thead><tr><th align="center">查看已添加的开发成员</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/tianjiakaifachengyuan4.jpg" alt="添加开发成员4"></td></tr></tbody></table><blockquote><p>5&gt; master分支设置为 <a href="">protected分支</a>，只有管理员有权限将代码合并到其中。dev分支设置为 <a href="">常规分支</a>所有开发人员    都可以其中合并代码</p></blockquote><table><thead><tr><th align="center">进入分支设置</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/baohufenzhi1.jpg" alt="保护分支1"></td></tr></tbody></table><table><thead><tr><th align="center">设置保护分支，让master分支不能被随更改</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/baohufenzhi2.jpg" alt="保护分支2"></td></tr></tbody></table><h4 id="10-2-开发人员"><a href="#10-2-开发人员" class="headerlink" title="10.2 开发人员"></a>10.2 开发人员</h4><blockquote><ul><li><p>初始化：在idea中clone 远程库，获得项目。会建立本地库</p></li><li><p>后续的开发中，都要在dev分支上进行。开发完一个功能并测试通过后就commit  提交到本地的dev分支中，然后 上传(push)到远程dev分支中。</p></li><li><p>需要更新项目内容时，通过 pull 从远程仓库拉取内容。   </p></li><li><p>注意：多人协同时，每次在 push 到远程库前，都先做一次pull，一来是把远程最新内容合并到本地，二来是核实本地内容是否和远程内容有冲突。</p></li><li><p>后续的开发，会接到一个个的功能任务，往复操作 2&gt;、3&gt;、4&gt; 而已。</p></li></ul></blockquote><h3 id="十一、经典问题"><a href="#十一、经典问题" class="headerlink" title="十一、经典问题"></a>十一、经典问题</h3><hr><blockquote><p>在使用https协议做push时，如果曾经使用过码云，但密码有过改动，此时会报错</p></blockquote><table><thead><tr><th align="center">使用https协议报错</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/keng1.jpg" alt="坑1"></td></tr></tbody></table><blockquote><p>解决方案:  <a href="">控制面板  》 凭据管理器 》</a> 删除对应凭证，再次使用时会提示重新输入密码。</p></blockquote><table><thead><tr><th align="center">删除之前的码云凭证，然后重新push即可</th></tr></thead><tbody><tr><td align="center"><img src="https://gllspictures.oss-cn-beijing.aliyuncs.com/img/keng2.jpg" alt="坑2"></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
